{"version":3,"names":[],"mappings":"","sources":["chartjs-plugin-labels.bundle.js"],"sourcesContent":["/**\n * [chartjs-plugin-labels]{@link https://github.com/DavideViolante/chartjs-plugin-labels}\n *\n * @version 5.0.1-beta\n * @author Chen, Yi-Cyuan [emn178@gmail.com], Davide Violante, Yousef Altaher\n * @copyright Chen, Yi-Cyuan 2017-2018\n * @license MIT\n */\n\n(function () {\n    'use strict';\n  \n    if (typeof Chart === 'undefined') {\n      console.error('Cannot find Chart object.');\n      return;\n    }\n  \n    // eslint-disable-next-line no-undef\n    const helpers = Chart.helpers;\n  \n    if (typeof Object.assign !== 'function') {\n      Object.assign = function (target) {\n        if (!target) {\n          throw new TypeError('Cannot convert undefined or null to object');\n        }\n        const to = Object(target);\n        for (let index = 1; index < arguments.length; index++) {\n          const nextSource = arguments[index];\n          if (nextSource) {\n            for (const nextKey in nextSource) {\n              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                to[nextKey] = nextSource[nextKey];\n              }\n            }\n          }\n        }\n        return to;\n      };\n    }\n  \n    const SUPPORTED_TYPES = {};\n    ['pie', 'doughnut', 'polarArea', 'bar'].forEach(function (t) {\n      SUPPORTED_TYPES[t] = true;\n    });\n  \n    function Label() {\n      this.renderToDataset = this.renderToDataset.bind(this);\n    }\n  \n    Label.prototype.setup = function (chart, options) {\n      this.chart = chart;\n      this.ctx = chart.ctx;\n      this.args = {};\n      this.barTotal = {};\n      const chartOptions = chart.config.options;\n      this.options = Object.assign({\n        position: 'default',\n        precision: 0,\n        fontSize: chartOptions.font ? chartOptions.font.size : 12,\n        fontColor: chartOptions.color || '#333333',\n        fontStyle: chartOptions.font ? chartOptions.font.style : 'normal',\n        fontFamily: chartOptions.font ? chartOptions.font.family : '\\'Helvetica Neue\\', \\'Helvetica\\', \\'Arial\\', sans-serif',\n        shadowOffsetX: 3,\n        shadowOffsetY: 3,\n        shadowColor: 'rgba(0,0,0,0.3)',\n        shadowBlur: 6,\n        images: [],\n        outsidePadding: 2,\n        textMargin: 2,\n        textHorizontalMargin: 0,\n        overlap: true,\n        style: '',\n      }, options);\n      if (chart.config.type === 'bar') {\n        this.options.position = 'default';\n        this.options.arc = false;\n        this.options.overlap = true;\n      }\n    };\n  \n    Label.prototype.render = function () {\n      this.labelBounds = [];\n      this.chart.data.datasets.forEach(this.renderToDataset);\n    };\n  \n    Label.prototype.renderToDataset = function (dataset, index) {\n      this.totalPercentage = 0;\n      this.total = null;\n      const arg = this.args[index];\n      arg.meta.data.forEach(function (element, index) {\n        this.renderToElement(dataset, arg, element, index);\n      }.bind(this));\n    };\n  \n    Label.prototype.renderToElement = function (dataset, arg, element, index) {\n      if (!this.shouldRenderToElement(arg.meta, element)) {\n        return;\n      }\n      this.percentage = null;\n      const label = this.getLabel(dataset, element, index);\n      if (!label) {\n        return;\n      }\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.font = helpers.fontString(this.options.fontSize, this.options.fontStyle, this.options.fontFamily);\n      const renderInfo = this.getRenderInfo(element, label);\n      if (!this.drawable(element, label, renderInfo)) {\n        ctx.restore();\n        return;\n      }\n      ctx.beginPath();\n      ctx.fillStyle = this.getFontColor(dataset, element, index);\n      this.renderLabel(label, renderInfo);\n      ctx.restore();\n    };\n  \n    Label.prototype.renderLabel = function (label, renderInfo) {\n      return this.options.arc ? this.renderArcLabel(label, renderInfo) : this.renderBaseLabel(label, renderInfo);\n    };\n  \n    Label.prototype.renderBaseLabel = function (label, position) {\n      const ctx = this.ctx;\n      if (typeof label === 'object') {\n        ctx.drawImage(label, position.x - label.width / 2, position.y - label.height / 2, label.width, label.height);\n      } else {\n        ctx.save();\n        ctx.textBaseline = 'top';\n        ctx.textAlign = 'center';\n  \n        if (this.options.textShadow) {\n          ctx.shadowOffsetX = this.options.shadowOffsetX;\n          ctx.shadowOffsetY = this.options.shadowOffsetY;\n          ctx.shadowColor = this.options.shadowColor;\n          ctx.shadowBlur = this.options.shadowBlur;\n        }\n  \n        const lines = label.split('\\n');\n        for (let i = 0; i < lines.length; i++) {\n          const y = position.y - this.options.fontSize / 2 * lines.length + this.options.fontSize * i;\n          ctx.fillText(lines[i], position.x, y);\n        }\n        ctx.restore();\n      }\n    };\n  \n    Label.prototype.renderArcLabel = function (label, renderInfo) {\n      const ctx = this.ctx, radius = renderInfo.radius, view = renderInfo.view;\n      ctx.save();\n      ctx.translate(view.x, view.y);\n      if (typeof label === 'string') {\n        ctx.rotate(renderInfo.startAngle);\n        ctx.textBaseline = 'middle';\n        ctx.textAlign = 'left';\n        const lines = label.split('\\n');\n        let max = 0;\n        const widths = [];\n        let offset = 0;\n        if (this.options.position === 'border') {\n          offset = (lines.length - 1) * this.options.fontSize / 2;\n        }\n        let mertrics;\n        for (let j = 0; j < lines.length; ++j) {\n          mertrics = ctx.measureText(lines[j]);\n          if (mertrics.width > max) {\n            max = mertrics.width;\n          }\n          widths.push(mertrics.width);\n        }\n        for (let j = 0; j < lines.length; ++j) {\n          const line = lines[j];\n          const y = (lines.length - 1 - j) * -this.options.fontSize + offset;\n          ctx.save();\n          const padding = (max - widths[j]) / 2;\n          ctx.rotate(padding / radius);\n          for (let i = 0; i < line.length; i++) {\n            const char = line.charAt(i);\n            mertrics = ctx.measureText(char);\n            ctx.save();\n            ctx.translate(0, -1 * radius);\n            ctx.fillText(char, 0, y);\n            ctx.restore();\n            ctx.rotate(mertrics.width / radius);\n          }\n          ctx.restore();\n        }\n      } else {\n        ctx.rotate((view.startAngle + Math.PI / 2 + renderInfo.endAngle) / 2);\n        ctx.translate(0, -1 * radius);\n        this.renderLabel(label, { x: 0, y: 0 });\n      }\n      ctx.restore();\n    };\n  \n    Label.prototype.shouldRenderToElement = function (meta, element) {\n      return !meta.hidden && (\n        this.options.showZero ||\n          this.chart.config.type === 'polarArea' ? element.outerRadius !== 0 : element.circumference !== 0\n      );\n    };\n  \n    Label.prototype.getLabel = function (dataset, element, index) {\n      let label;\n      if (typeof this.options.render === 'function') {\n        label = this.options.render({\n          label: this.chart.config.data.labels[index],\n          value: dataset.data[index],\n          percentage: this.getPercentage(dataset, element, index),\n          dataset,\n          index\n        });\n      } else {\n        switch (this.options.render) {\n          case 'value':\n            label = dataset.data[index];\n            break;\n          case 'label':\n            label = this.chart.config.data.labels[index];\n            break;\n          case 'image':\n            label = this.options.images[index] ? this.loadImage(this.options.images[index]) : '';\n            break;\n          case 'percentage':\n          default:\n            label = this.getPercentage(dataset, element, index) + '%';\n            break;\n        }\n      }\n      if (typeof label === 'object') {\n        label = this.loadImage(label);\n      } else if (label) {\n        label = label.toString();\n      }\n      return label;\n    };\n  \n    Label.prototype.getFontColor = function (dataset, element, index) {\n      let fontColor = this.options.fontColor;\n      if (typeof fontColor === 'function') {\n        fontColor = fontColor({\n          label: this.chart.config.data.labels[index],\n          value: dataset.data[index],\n          percentage: this.getPercentage(dataset, element, index),\n          backgroundColor: dataset.backgroundColor[index],\n          dataset,\n          index\n        });\n      } else if (typeof fontColor !== 'string') {\n        fontColor = fontColor[index] || this.chart.config.options.color;\n      }\n      return fontColor;\n    };\n  \n    Label.prototype.getPercentage = function (dataset, element, index) {\n      if (this.percentage) {\n        return this.percentage;\n      }\n      let percentage;\n      if (this.chart.config.type === 'polarArea' || this.chart.config.type === 'doughnut' || this.chart.config.type === 'pie') {\n        if (!this.total) {\n          this.total = 0;\n          for (let i = 0; i < dataset.data.length; ++i) {\n            this.total += dataset.data[i];\n          }\n        }\n        percentage = dataset.data[index] / this.total * 100;\n      } else if (this.chart.config.type === 'bar') {\n        if (!this.barTotal[index]) {\n          this.barTotal[index] = 0;\n          for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n            this.barTotal[index] += this.chart.data.datasets[i].data[index];\n          }\n        }\n        percentage = dataset.data[index] / this.barTotal[index] * 100;\n      } else {\n        percentage = element.circumference / this.chart.config.options.circumference * 100;\n      }\n      percentage = parseFloat(percentage.toFixed(this.options.precision));\n      if (!this.options.showActualPercentages) {\n        if (this.chart.config.type === 'bar') {\n          this.totalPercentage = this.barTotalPercentage[index] || 0;\n        }\n        this.totalPercentage += percentage;\n        if (this.totalPercentage > 100) {\n          percentage -= this.totalPercentage - 100;\n          percentage = parseFloat(percentage.toFixed(this.options.precision));\n        }\n        if (this.chart.config.type === 'bar') {\n          this.barTotalPercentage[index] = this.totalPercentage;\n        }\n      }\n      this.percentage = percentage;\n      return percentage;\n    };\n  \n    Label.prototype.getRenderInfo = function (element, label) {\n      if (this.chart.config.type === 'bar') {\n        return this.getBarRenderInfo(element, label);\n      } else {\n        return this.options.arc ? this.getArcRenderInfo(element, label) : this.getBaseRenderInfo(element, label);\n      }\n    };\n  \n    Label.prototype.getBaseRenderInfo = function (element, label) {\n      if (this.options.position === 'outside' || this.options.position === 'border') {\n        let renderInfo = {};\n        let rangeFromCentre;\n        const view = element;\n        const centreAngle = view.startAngle + (view.endAngle - view.startAngle) / 2;\n        const innerRadius = view.outerRadius / 2;\n        if (this.options.position === 'border') {\n          rangeFromCentre = (view.outerRadius - innerRadius) / 2 + innerRadius;\n        } else if (this.options.position === 'outside') {\n          rangeFromCentre = (view.outerRadius - innerRadius) + innerRadius + this.options.textMargin;\n        }\n        renderInfo = {\n          x: view.x + (Math.cos(centreAngle) * rangeFromCentre),\n          y: view.y + (Math.sin(centreAngle) * rangeFromCentre)\n        };\n        if (this.options.position === 'outside') {\n          const offset = this.options.textMargin + this.measureLabel(label).width / 2;\n          renderInfo.x += renderInfo.x < view.x ? -offset : offset;\n        }\n        return renderInfo;\n      } else {\n        return element.tooltipPosition();\n      }\n    };\n  \n    Label.prototype.getArcRenderInfo = function (element, label) {\n      let radius;\n      const view = element;\n      if (this.options.position === 'outside') {\n        radius = view.outerRadius + this.options.fontSize + this.options.textMargin;\n      } else if (this.options.position === 'border') {\n        radius = (view.outerRadius / 2 + view.outerRadius) / 2;\n      } else {\n        radius = (view.innerRadius + view.outerRadius) / 2;\n      }\n      let startAngle = view.startAngle, endAngle = view.endAngle;\n      const totalAngle = endAngle - startAngle;\n      startAngle += Math.PI / 2;\n      endAngle += Math.PI / 2;\n      const mertrics = this.measureLabel(label);\n      startAngle += (endAngle - (mertrics.width / radius + startAngle)) / 2;\n      return { radius, startAngle, endAngle, totalAngle, view };\n    };\n  \n    Label.prototype.getBarRenderInfo = function (element, label) {\n      const renderInfo = element.tooltipPosition();\n      renderInfo.y -= this.measureLabel(label).height / 2 + this.options.textMargin;\n      if (this.options.textHorizontalMargin !== 0) {\n        renderInfo.x += this.options.textHorizontalMargin;\n      }\n      \n      return renderInfo;\n    };\n  \n    Label.prototype.drawable = function (element, label, renderInfo) {\n      if (this.options.overlap) {\n        return true;\n      } else if (this.options.arc) {\n        return renderInfo.endAngle - renderInfo.startAngle <= renderInfo.totalAngle;\n      } else {\n        const mertrics = this.measureLabel(label),\n          left = renderInfo.x - mertrics.width / 2,\n          right = renderInfo.x + mertrics.width / 2,\n          top = renderInfo.y - mertrics.height / 2,\n          bottom = renderInfo.y + mertrics.height / 2;\n        if (this.options.position === 'outside') {\n          return this.outsideInRange(left, right, top, bottom);\n        } else {\n          return element.inRange(left, top) && element.inRange(left, bottom) &&\n            element.inRange(right, top) && element.inRange(right, bottom);\n        }\n      }\n    };\n  \n    Label.prototype.outsideInRange = function (left, right, top, bottom) {\n      const labelBounds = this.labelBounds;\n      for (let i = 0; i < labelBounds.length; ++i) {\n        const bound = labelBounds[i];\n        let potins = [\n          [left, top],\n          [left, bottom],\n          [right, top],\n          [right, bottom]\n        ];\n        for (let j = 0; j < potins.length; ++j) {\n          const x = potins[j][0];\n          const y = potins[j][1];\n          if (x >= bound.left && x <= bound.right && y >= bound.top && y <= bound.bottom) {\n            return false;\n          }\n        }\n        potins = [\n          [bound.left, bound.top],\n          [bound.left, bound.bottom],\n          [bound.right, bound.top],\n          [bound.right, bound.bottom]\n        ];\n        for (let j = 0; j < potins.length; ++j) {\n          const x = potins[j][0];\n          const y = potins[j][1];\n          if (x >= left && x <= right && y >= top && y <= bottom) {\n            return false;\n          }\n        }\n      }\n      labelBounds.push({ left, right, top, bottom });\n      return true;\n    };\n  \n    Label.prototype.measureLabel = function (label) {\n      if (typeof label === 'object') {\n        return { width: label.width, height: label.height };\n      } else {\n        let width = 0;\n        const lines = label.split('\\n');\n        for (let i = 0; i < lines.length; ++i) {\n          const result = this.ctx.measureText(lines[i]);\n          if (result.width > width) {\n            width = result.width;\n          }\n        }\n        const height = this.options.fontSize * lines.length;\n        return { width, height };\n      }\n    };\n  \n    Label.prototype.loadImage = function (obj) {\n      const image = new Image();\n      image.src = obj.src;\n      image.width = obj.width;\n      image.height = obj.height;\n      return image;\n    };\n  \n    function isPluginsLabelsDefined(options) {\n      const chartConfig = options._context.chart.config._config;\n      if (chartConfig.options && chartConfig.options.plugins)\n        return !!chartConfig.options.plugins.labels;\n      return false;\n    }\n    // eslint-disable-next-line no-undef\n    Chart.register({\n      id: 'labels',\n      beforeDatasetsUpdate: function (chart, args, options) {\n        if (!SUPPORTED_TYPES[chart.config.type] || !isPluginsLabelsDefined(options)) {\n          return;\n        }\n        if (!options.length) {\n          options = [options];\n        }\n        const count = options.length;\n        if (!chart._labels || count !== chart._labels.length) {\n          chart._labels = options.map(function () {\n            return new Label();\n          });\n        }\n        let someOutside = false, maxPadding = 0;\n        for (let i = 0; i < count; ++i) {\n          const label = chart._labels[i];\n          label.setup(chart, options[i]);\n          if (label.options.position === 'outside') {\n            someOutside = true;\n            const padding = label.options.fontSize * 1.5 + label.options.outsidePadding;\n            if (padding > maxPadding) {\n              maxPadding = padding;\n            }\n          }\n        }\n        if (someOutside) {\n          chart.chartArea.top += maxPadding;\n          chart.chartArea.bottom -= maxPadding;\n        }\n      },\n      afterDatasetUpdate: function (chart, args, options) {\n        if (!SUPPORTED_TYPES[chart.config.type] || !isPluginsLabelsDefined(options)) {\n          return;\n        }\n        chart._labels?.forEach(function (label) {\n          label.args[args.index] = args;\n        });\n      },\n      beforeDraw: function (chart, args, options) {\n        if (!SUPPORTED_TYPES[chart.config.type] || !isPluginsLabelsDefined(options)) {\n          return;\n        }\n        chart._labels?.forEach(function (label) {\n          label.barTotalPercentage = {};\n        });\n      },\n      afterDatasetsDraw: function (chart, args, options) {\n        if (!SUPPORTED_TYPES[chart.config.type] || !isPluginsLabelsDefined(options)) {\n          return;\n        }\n        chart._labels?.forEach(function (label) {\n          label.render();\n        });\n      }\n    });\n  })();\n  "],"file":"chartjs-plugin-labels.bundle.js"}